# [MainPage](../readme.md)/Java  

-
```java
public class VariableDemo{
	public static void main(String[] args){
		
	}
}
```
**calss**:​ 表示定义一个`类`。创建一个类。  

**类**：Java项目最基本的组成单元，一个完整的Java项目有可能会有成千上万个类来组成的。  

class后面跟随的就是这个类的名字，简称：类名。  

类的实现包括两部分：`类的声明`和`类体`。  

**类体**:包括类声明之后的*一对大括号{ }以及它们之间的内容*成为类体，大括号之间的内容称为类体的内容。  

类体分为两部分：`变量的声明`和`方法的定义`。  



```
class 类名{

        变量的声明;

        方法的定义;

    }
```

"VariableDemo"后的大括号表示这个类的范围。  

**public**：表内示程序的访问权限，表示的是任何的场合可以被引用。  

**main**:Java应用程序的入口方法(JVM找到这个程序的入口)，将其声明为public即对外公开，因此JVM便能直接调用它。  
每一个应用程序都必须包含一个main()方法，含有main()方法的类称为主类。  
**static**  
**void**  

## 变量 
  - **变量**分为`成员变量`和`局部变量`  

    - **成员变量**：是变量声明部分声明的变量。（成员变量分为：`实例变量`、`类变量`。用*static*修饰的为类变量（*static变量，也叫静态变量*），否则为实例变量）  

    - **局部变量**：在方法体中声明的变量和方法的参数。  

- **变量的有效范围**
  - `成员变量`在整个类中都有效。
  - `局部变量`只在声明它的方法内有效
  - 方法参数在整个方法内有效。
  - 方法内的局部变量从声明它的位置之后开始有效。  

- **成员变量的隐藏**  
    如果局部变量的名字和成员变量的名字相同，则成员变量被隐藏（即这个成员变量在这个方法内暂时失效）。
  

## 键盘录入
```java
//1.导包，先找到Scanner这个类在哪(idea在进行步骤2后会自动进行导包)
import java.util.Scanner;
public class class1 {
    public static void main(String[] args) {
        //2.创建对象，申明一下，我准备开始用Scanner这个类了。
        Scanner sc = new Scanner(System.in);
        System.out.println("请输入一个数字");
		//3.接收数据
        int i = sc.nextInt();
        System.out.println(i);
    }
}
```
```java
import java.util.Scanner;
```
导包的动作必须出现在类的定义上  
```java
Scanner sc = new Scanner(System.in);
```
此行代码中只有sc为变量名，可变，其余均不可变  
```java
int i = sc.nextInt();
```
其中只有后半为接收数据，前半意为将接收的数据赋值给变量i。此行代码中只有i为变量名，可变，其余均不可变  

## 运算符及表达式  

- **算术运算符**    
对常量或者变量进行操作的符号  

| 运算符 | 说明 |
|-------|------|
| + | 加 |
| - | 减 |
| * | 乘 |
| / | 除 |
| % | 取余数 |  

```java
/*
1.整数相除结果只能得到整除，如果结果想要是小数，必须要有小数参数。
2.小数直接参与运算，得到的结果有可能是不精确的。*/
System.out.println( 10 / 3);//3
System.out.println(10.0 / 3);//3.3333333333333335
```

```java
/*%：取模、取余。
   他做的也是除法运算，只不过获取的是余数而已。*/
System.out.println(10 % 2);//0
System.out.println(10 % 3);//1  
```

- **自增自减运算符**  
自增、自减运算符的作用是使变量的值
增1或减1。  
放在操作元前面的自增、自减运算符，会先将变量的值加1（减1），然后再使该变量参与表达式的运算。  
放在操作元后面的自增、自减运算符，会先使变量参与表达式的运算，然后再将该变量加1（减1）。  
```java
int a = 4;
int b = ++a;//此时b=5，a=5，即a先自增为5再赋值给b
```  

```java
int a = 4;
int b = a++;//此时b=4，a=5，即a先赋值给b再自增为5
```  

**注意**  不管是先++，还是后++。单独写在一行的时候，运算结果是一模一样的。
```java
int a = 4;
++a;
System.out.println(a);
a++;
System.out.println(a);
//以上输出结果均为5
```

- **赋值运算符**  
  - `=` 把等号右边的结果赋值给左边的变量
  - `+=` `-=` `*=` `/=` `%=` 把左边跟右边进行运算，把最终的结果赋值给左边，对右边没有任何影响。  
  
```java
public class example {
  public static void main(String[]args){
    int a = 10;
    int b = 20:
    a += b;//先将a与b相加得到30，再将30赋值给a，对b无影响
    System.out.println(a);//30
    System.out.println(b);//20
  }
}

```  

**注意** 扩展的赋值运算符中隐层还包含了一个强制转换。以下介绍类型转换

- **隐式转换和强制转换**  
  - `隐式转换`也叫自动类型提升。
就是把一个取值范围小的数据或者变量，赋值给另一个取值范围大的变量。此时不需要我们额外写代码单独实现，是程序自动帮我们完成的。  
 
    *规则*  
    - 取值范围小的，和取值范围大的进行运算，小的会先提升为大的，再进行运算。
    - byte、short、char三种类型的数据在运算的时候，都会直接先提升为int，然后再进行运算。
    - byte<short<int< long <float <double  
  - `强制转换`  
    如果要把一个取值范围大的数据或者变量赋值给另一个取值范围小的变量。是不允许直接操作。如果一定要这么干，就需要加入强制转换。  
  
    *书写格式*
    - 目标数据类型 变量名 = （目标数据类型）被强转的数据( 要转成什么类型的，那么就在小括号中写什么类型就可以了。)  

```java
public class example {
    public static void main(String[] args) {
        double a = 12.3;
        int b = (int) a;
        System.out.println(b);//12
    }
}
```  

现在我们回到赋值运算符中隐含的强制转换并给出例子
 
```java
public class OperatorDemo8 {
    public static void main(String[] args) {
        byte a = 10;
        byte b = 20;
        //a += b;
        a = (byte)(a + b);
        System.out.println(a);//30
    }
}
```  
这里的a += b ;实际上相当于 a = (byte)(a + b);  

- **关系运算符（比较运算符）**    

|符号|解释|
|----|----|
| ==   | 就是判断左边跟右边是否相等，如果成立就是true，如果不成立就是false |
| !=   | 就是判断左边跟右边是否不相等，如果成立就是true，如果不成立就是false |
| >    | 就是判断左边是否大于右边，如果成立就是true，如果不成立就是false |
| >=   | 就是判断左边是否大于等于右边，如果成立就是true，如果不成立就是false |
| <    | 就是判断左边是否小于右边，如果成立就是true，如果不成立就是false |
| <=   | 就是判断左边是否小于等于右边，如果成立就是true，如果不成立就是false |  

```java
int a = 10;
int b = 20;
System.out.println( a > b );
```  
```java
int a = 10;
int b = 20;
boolean c = a > b;
System.out.println( c );
```  

- **逻辑运算符**

|符号|解释|
|----|----|
|`&`逻辑与（而且）|两边都为真，结果才是真，只要有一个为假，那么结果就是假。|
|逻辑或（或者） |两边都为假，结果才是假，只要有一个为真，那么结果就是真。|                                        
|`^`异或|如果两边相同，结果为false，如果两边不同，结果为true|
|`!`取反|false取反就是true，true取反就是false|  

- **短路逻辑运算符**   
`&&` `||`  
运算结果与&（|）一致，只不过具有短路效果。即当左边不能确定整个表达式的结果，右边才会执行。如若左边能确定整个表达式的结果，那么右边就不会执行，从而*提高代码的运行效率*。  

- **三元运算符**  
  
  - `格式` 关系表达式？表达式1：表达式2；  
  - `计算规则`   
    计算关系表达式的值。
    如果关系表达式的值为真，那么执行表达式1。
    如果关系表达式的值为假，那么执行表达式2。  

 ```java
 public class OperatorDemo12 {
    public static void main(String[] args) {      
        int a = 10;
        int b = 20;      
       int max =  a > b ? a : b ;//格式：关系表达式 ？ 表达式1 ： 表达式2
        System.out.println(max);
        System.out.println(a > b ? a : b);
    }
}
 ```     

 **注意**  
 此处的表达式1及表达式2不一定为关系表达式里的内容。  

 `举例`  
 ```java
 public class OperatorDemo12 {
   public static void main(String[] args) {      
       int a = 10;
       int b = 20;  
       int c = 30;
       int d = 40;    
      int max =  a > b ? c : d ;
       System.out.println(max);
       System.out.println(a > b ? c : d);
   }

 ```  

 此处a > b 判断为false，输出表达式2，即40（d）  

 ## 计算机底层运行逻辑-原码，反码及补码  

 ### 什么是原码？  
 计算机中一个0或一个1被称为一个bit，8个bit被称为一个字节。  

 `0000 0000`这个就是一个字节，其中第一位为`符号位`，后面七位为`数据`。  

 `符号位`功能是记录该数据正负，`数据`则是具体的数值  

 一个字节最大是`0111 1111`即127，最小是`1111 1111`即-127  

 ### 原码  
 十进制数据的二进制表现形式，最左边是符号位，0为正，1为负。  

 利用原码对正数进行计算不会有问题。  

 ### 原码的弊端  
 **例子**  
 `1000 0000`代表-0，-0同为0  

 此时对0+1正常结果为1，但此处原码进行加1得到的是`1000 0001`显示为-1  

 导致出现这种弊端的原因是由于符号位并不参与计算而导致的。就好比数轴加1本因向数轴正方向走一格，但由于-0其符号位为负数，导致加1变为向数轴负方向走一格，从而得到的结果为-1。  

 为解决这种弊端出现了反码。  

 ### 反码  
 反码如若类比上文提到的数轴就相当于将数轴反过来。  

 其计算规则为：正数的反码不变等同于原码，负数在原码的基础上，符号位不变，数值取反，0变1，1变0。  

 |十进制数|原码|反码|
 |-------|----|----|
 |-1|1000 0001|1111 1110|
 |-2|1000 0010|1111 1101|
 |-3|1000 0011|1111 1100|
 |-4|1000 0100|1111 1011|
 |-5|1000 0101|1111 1010|
 |-6|1000 0110|1111 1001|  

 此时如果将-4 ——`1111 1011` 进行减1，就会得到`1111 1010`即-5，进行加1，就会得到`1111 1100` 即-3。  

 这种情况下计算并无问题，但反码仍有其弊端。  

 例如：  

 -0原码为`1000 0000`,其反码为`1111 1111`  

 +0原码为`0000 0000`,其反码为`0000 0000`  

 此时如果将-0`1111 1111`加1将会得到+0`0000 0000`  

 故当反码中负数进行跨0计算时将会产生1的误差。  

 为解决此种弊端出现了补码。  

 ### 补码  

 补码可看作将反码向下错一位。 

 由于0在反码中有两种表现形式即-0与+0，故在补码中多出了一位`1000 0000`计算机中将其规定为-128，其无原码及反码。因此一个字节的范围为-128~127。    
 
 ==注意==：正数的反码，补码均与原码一致。 


   |十进制数|原码|反码|补码|
 |-------|----|----|----|
 |+0|0000 0000|0000 0000|0000 0000|
 |-0|1000 0000|1111 1111|0000 0000|
 |-1|1000 0001|1111 1110|1111 1111|
 |-2|1000 0010|1111 1101|1111 1110|
 |-3|1000 0011|1111 1100|1111 1101|
 |-4|1000 0100|1111 1011|1111 1100|
 |-5|1000 0101|1111 1010|1111 1011|
 |-6|1000 0110|1111 1001|1111 1010|
 |...|...|...|...|
 |-126|1111 1110|1000 0001|1000 0010|
 |-127|1111 1111|1000 0000|1000 0001|
 |-128|无|无|1000 0000|  

 现在我们对之前的一些知识点进行进一步解释。  

 ### 对隐式转换及强制转换的解释  

 byte类型的10 `1个字节` 0000 1010  

 short类型的10 `2个字节` 0000 0000 0000 1010

 int类型的10 `4个字节` 0000 0000 0000 0000 0000 0000 0000 1010

 long类型的10 `8个字节` 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 1010  

- **隐式转换**
 ```java
 public class example{
  public static void main(String[]args){
    byte a = 10;//0000 1010
    int b = a;//0000 0000 0000 0000 0000 0000 0000 1010
  }
 }
 ```  

 隐式转换就是在原有字节上补0，补到转换后变量的字节。  

- **强制转换**
```java
 public class example{
  public static void main(String[]args){
    int a = 300;//0000 0000 0000 0000 0000 0001 0010 1100
    byte b = (byte)a;//0010 1100
  }
 }
 ```   

强制转换就是强制去掉原有变量前多余的字节使其变为强制转换的变量的应有的字节，而在强制去除字节时可能去掉其中的数据使其转换后的数据与原有数据不同，这就是强制转换有可能出错的原因。  

## 对于其他运算符的解释  

==&(逻辑与)== 0为false,1为true  
```java
public class example{
  public static void main(String[]args){
    int a = 200;//0000 0000 0000 0000 0000 0000 1100 1000
    int b = 10;//0000 0000 0000 0000 0000 0000 0000 1010
    System.out.println(a & b);
  }
 }
```  

对a & b进行计算(同为true即1才为true)
```
  0000 0000 0000 0000 0000 0000 1100 1000
& 0000 0000 0000 0000 0000 0000 0000 1010
-----------------------------------------
  0000 0000 0000 0000 0000 0000 0000 1000 //8
```

```java
System.out.println(a & b);//故输出结果为8
```  

==|(逻辑或)==  0为false,1为true
```java
public class example{
  public static void main(String[]args){
    int a = 200;//0000 0000 0000 0000 0000 0000 1100 1000
    int b = 10;//0000 0000 0000 0000 0000 0000 0000 1010
    System.out.println(a | b);
  }
 }
```  

对a | b进行计算(只要有true即1就为true)
```
  0000 0000 0000 0000 0000 0000 1100 1000
& 0000 0000 0000 0000 0000 0000 0000 1010
-----------------------------------------
  0000 0000 0000 0000 0000 0000 1100 1010 //202
```

```java
System.out.println(a | b);//故输出结果为202
```   

==<<(左移)== 向左移位，低位补0  

```java
public class example{
  public static void main(String[]args){
    int a = 200;//0000 0000 0000 0000 0000 0000 1100 1000
    System.out.println(a << 2);//左移2位
  }
 }
```   

`00|00 0000 0000 0000 0000 0000 1100 1000 00|`得到800  

左移一次结果乘2

==>>(右移)== 向右移动，高位补0低位或1  

如果是正数则最高位补0，如果是负数则最高位补1。  

右移一次除2  

==>>>(无符号右移)== 向右移动，高位补0  

无论正负数最高位均补0  


























