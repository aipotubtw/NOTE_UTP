# 布尔函数

布尔函数是一个数学函数，它接受一组布尔变量（每个变量只有两个可能的值：0或1），并返回一个布尔值（0或1）。布尔函数通常用符号 
$$
f(X_1, X_2, \ldots, X_n)
$$ 
表示，其中 \(X_1, X_2, \ldots, X_n\) 是布尔变量。

# 立方体表示

立方体表示是将布尔函数的输入视为n维立方体的顶点。对于n个变量，所有可能的参数组合（共有 \(2^n\) 种组合）可以视为n维立方体中的顶点。这个立方体的边长为1，表示每个变量只能取值0或1。

例如，对于3个变量 \(X_1, X_2, X_3\)，所有可能的输入组合为：

- (0, 0, 0)
- (0, 0, 1)
- (0, 1, 0)
- (0, 1, 1)
- (1, 0, 0)
- (1, 0, 1)
- (1, 1, 0)
- (1, 1, 1)

这些组合分别对应于3维立方体的8个顶点。

# 重要顶点（0-立方体）

在立方体表示中，布尔函数为1的输入组合被称为重要顶点或有效顶点。这些顶点对应于布尔函数为真（1）的情况。

例如，假设布尔函数 
$$
f(X_1, X_2, X_3)
$$ 
为1的输入组合是 (0, 1, 0) 和 (1, 1, 1)，那么这两个组合就是重要顶点。这些重要顶点形成了所谓的零立方体（0-立方体）。零立方体是一种特殊的立方体，它只包含布尔函数为1的顶点。

# 邻接关系

在立方体表示中，两个零立方体被称为邻接，当且仅当它们在一个坐标上不同。也就是说，它们的输入组合只在一个变量的值上有所不同。

例如，零立方体 (0101) 和 (0001) 是邻接的，因为它们仅在第二个变量上不同。

# 拼接操作

如果两个零立方体邻接，可以通过拼接操作得到一个一立方体（1-立方体）。拼接的结果是将邻接的两个零立方体中的相同部分保留，而不同的部分用一个符号（通常用 \(X\) 表示）表示，这个符号表示该坐标可以取值0或1，称为自由坐标。

在示例中：  
零立方体 (0101) 和 (0001) 拼接的结果是 (0X01)，这里的 \(X\) 表示第二个坐标的值可以是0或1。

# 扩展到更高维

邻接关系和拼接操作不仅限于零立方体，也适用于一立方体和更高维的立方体。例如，两个一立方体可以拼接成一个二立方体（2-立方体），依此类推。

# 总结

立方体表示布尔函数是分析和表示布尔函数的一种直观方式。通过邻接关系和拼接操作，我们可以从零立方体（重要顶点）出发，构建出更高维的立方体结构。这在组合优化、数字电路设计等领域具有重要的应用。

## 最大立方体的特征
最大立方体有以下特征：
1. **不可被粘合**：最大立方体是无法与其他立方体进行粘合（合并）操作的。粘合操作通常用于将两个或多个较小的立方体合并为一个更大的立方体，从而减少逻辑表达式的复杂性。如果一个立方体与其他立方体存在冲突（如某些输入状态下输出不同），它就无法参与粘合。

2. **涵盖所有相关的输入状态**：在给定的布尔函数中，最大立方体能够涵盖所有相关的输入状态，且这些状态是无法进一步细分的。

3. **表示功能最小化**：最大立方体通常用于布尔函数的最小化和简化，因为它们能够代表最有效的覆盖，而不会引入冗余。

## 最大立方体集合 Z(f)  

- 所有的最大立方体构成一个集合，记作 Z(f)。这个集合包含了函数 f 的所有最大立方体，它是粘合操作的最终结果。


### 示例 2.8

对于函数 \( f_4(X) \)，确定其 0-立方体 \( (0101) \) 和 \( (0001) \) 是否相邻，如果相邻，则执行它们的拼接操作。

给定的立方体是相邻的，因为它们只在一个坐标上不同。它们的拼接结果是 1-立方体 \( (0X01) \)。标记为 \( X \) 的坐标称为**自由坐标**（独立、不受约束），其余（数值的）坐标称为**受约束坐标**（依赖、受约束）。

类似的相邻关系也存在于 1-立方体之间，拼接 1-立方体的结果是 2-立方体。

### 示例 2.9

对于函数 \( f_4(X) \)，确定其 1-立方体 \( (0X01) \) 和 \( (0X11) \) 是否相邻，如果相邻，则执行它们的拼接操作。

给定的立方体是相邻的，因为它们只在一个坐标上不同。它们的拼接结果是 2-立方体 \( (0XX1) \)。

**概括**：两个 \( r \)-立方体被称为相邻的，如果它们只在一个（依赖的）坐标上不同。每个 \( r \)-立方体包含 \( r \) 个独立的和 \( n - r \) 个依赖的坐标。拼接两个相邻的 \( r \)-立方体会生成一个 \( (r+1) \)-立方体，包含 \( r+1 \) 个独立坐标。

## 最小覆盖布尔函数  

- 所有的最大立方体构成一个集合，记作 Z(f)。这个集合包含了函数 f 的所有最大立方体，它是粘合操作的最终结果。


### 第一步：构造和识别核心覆盖

立方体 `(00X)` 的作用：

`(00X)` 表示它可以匹配所有前两位为 "00" 的组合，即它覆盖了两个顶点：`001` 和 `000`。重要的是，只有这个立方体 `(00X)` 能覆盖顶点 `001`，这使得它成为覆盖中必不可少的一部分。即如果没有它，顶点 `001` 就无法被任何其他立方体覆盖。

立方体 `(11X)` 的作用：

类似地，`(11X)` 匹配所有前两位为 "11" 的组合，覆盖了两个顶点：`111` 和 `110`。只有 `(11X)` 能覆盖顶点 `111`，因此它也必须包含在覆盖中。否则，顶点 `111` 将无法被其他立方体覆盖。

因此，我们知道：

- `(00X)` 和 `(11X)` 是核心立方体，因为它们分别覆盖了布尔函数中的重要顶点 `(001)` 和 `(111)`。
- 核心覆盖 `T(f) = {00X, 11X}` 这个集合包含这些不可缺少的立方体。

### 第二步：处理剩余的顶点

其他顶点的覆盖情况：

`(00X)` 和 `(11X)` 不仅覆盖了 `(001)` 和 `(111)`，还分别覆盖了 `(000)` 和 `(110)`。这意味着，这两个立方体已经覆盖了布尔函数的部分顶点，包括 `(000)` 和 `(110)`，无需再为它们寻找额外的立方体。

剩下的顶点 `(100)`：

现在唯一还未被覆盖的顶点是 `(100)`。为了覆盖它，我们可以选择两个最大立方体中的任何一个：`(X00)` 或 `(1X0)`。

- `(X00)` 覆盖了 `(000)` 和 `(100)`，
- `(1X0)` 覆盖了 `(100)` 和 `(110)`。

因此，选择其中任意一个即可确保所有顶点都被覆盖。最终，这样的集合就是布尔函数的最小覆盖。

- 获取最小析取范式（ДНФ）的任务可以归结为获取布尔函数的最小覆盖的任务。
一般情况下，获取最小覆盖的过程如下：
- а 找到最大立方体的集合；
- б 确定覆盖的核心；
- в 从未包含在核心中的最大立方体集合中选择一个最小子集，以覆盖未被核心覆盖的重要顶点
